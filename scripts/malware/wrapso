#!/bin/bash
# Written and maintained by Cardinal
# Last modified: 6/18/2019 
BASE_DIR=`pwd`
declare DELETE_LIST
FLAGS="-DWRAPSO"
LINKED_DIR="sos"
OVERWRITE=0
SAVE_CHILDREN=0
VERBOSE=0

if [ -f *.so ]; then
	mv *.so "$(ls *.so).bup"
fi

while getopts ":f:corsv" opt; do
	case ${opt} in
		c )
			rm -r $LINKED_DIR
			printf "Cleaned up!\n"
			exit 0
			;;
		f )
			FLAGS="$FLAGS -D$OPTARG"
			;;
		o )
			OVERWRITE=1
			;;
		r )
			SOURCE_PATH=$( dirname "${BASH_SOURCE[0]}" )
			if [ -f "$SOURCE_PATH/resolve.sh" ]; then
				"$SOURCE_PATH/resolve.sh"
				printf "\n==========\n\n"
			else
				printf "Couldn't find resolve.sh in wrapso's source directory!"
			fi
			;;
		s )
			SAVE_CHILDREN=1
			;;
		v )
			VERBOSE=1
			;;
		\? )
			printf "Invalid option \"-$OPTARG\"!\n"
			exit 1
			;;
	esac
done

if [ ! -f "mod.dep" ]; then
	printf "WARNING: Couldn't find a \"mod.dep\".\n\n"
fi

function wrapso(){
	#Checking for a Makefile

	if [[ `make -n` == "" ]]; then
		printf "Could not identify any valid Make options in `pwd`!\n"
		exit 2
	fi

	local BUILD_STR="`make -n` $FLAGS -L./$LINKED_DIR -Wl,-rpath,./$LINKED_DIR/"
	local wd=`pwd`
	local CATCH_EXIT=0

	#Make the linked directory if it doesn't already exist and it's necessary
	if [[ ! -d "$LINKED_DIR" ]] && [[ -f "mod.dep" ]]; then
		mkdir $LINKED_DIR
	fi

	#Build out dependancies
	local args
	if [ -f "mod.dep" ]; then
		while read -r line;do
			args+=( "`echo "$line"`" )
		done < "mod.dep"
		if [[ $args == "" ]]; then
			printf "WARNING: `pwd`/mod.dep is empty.\n\n"
		fi
	fi

	for i in ${args[@]}; do
		local CHILD_PATH=${i%/}
		#If a directory path was passed
		if [ -d "$CHILD_PATH" ]; then
			cd $CHILD_PATH
			FILE=$(ls ./*.so 2>/dev/null)

			#If the file doesn't already exist
			if [[ "$FILE" == "" ]] || [[ $OVERWRITE == 1 ]]; then
				#Make the file
				if [[ $VERBOSE == 1 ]]; then
					if [ -f "mod.dep" ]; then
						printf "Making $CHILD_PATH to link properly, then deleting the incomplete .so.\n"
					else
						printf "Making $CHILD_PATH.\n"
					fi
				fi
				make 1>&2 2>/dev/null

				FILE=$(ls ./*.so 2>/dev/null)

				#If the make didn't work
				if [[ $FILE == "" ]]; then
					printf "Couldn't make $CHILD_PATH; ensure that it can make properly and re-run the script.\n"
					exit 2
				fi

				FILE=${FILE:2}
				if [ -f "mod.dep" ]; then
					rm $FILE
				else
					if [[ $VERBOSE == 1 ]]; then
						printf "Moving $CHILD_PATH over to the local directory.\n"
					fi

					#Stripping the module of entryPoint and moving to wd
					objcopy -N entryPoint $FILE
					cp $FILE $wd/$LINKED_DIR/lib$FILE
				fi

				#Adding the files over to the delete path (since they didn't alreay exist)
				if [[ ! "${DELETE_LIST[@]}" =~ "`pwd`/*.so" ]]; then
					DELETE_LIST+=( "`pwd`/*.so" )
					if [[ -d "`pwd`/$LINKED_DIR" ]]; then
						DELETE_LIST+=( "`pwd`/$LINKED_DIR" )
					fi
				fi

			#If the file already exists
			else
				FILE=${FILE:2}
				if [[ $VERBOSE == 1 ]]; then
					printf "Found $CHILD_PATH, copying over to the local directory.\n"
				fi

				#Stripping the module of entryPoint and copying to wd
				objcopy -N entryPoint $FILE
				cp $FILE $wd/$LINKED_DIR/lib$FILE
			fi

			cd $wd
		else
			printf "Could not interpret $CHILD_PATH as a valid directory path.\n" 
			exit 2
		fi

		#Build the link into the gcc build string
		local FILE_LEN=${#FILE}
		local LINK_NAME=${FILE:0:FILE_LEN-3}
		BUILD_STR="$BUILD_STR -l$LINK_NAME"

		#Resolving dependancies
		cd $CHILD_PATH
		if [ -f "mod.dep" ]; then
			wrapso
		fi
		cd $wd;
	done

	#Sending .so files back up the chain
	for i in ${args[@]}; do
		CHILD_PATH=${i%/}
		cd $CHILD_PATH
		FILE=$(ls ./*.so 2>/dev/null)
		FILE=${FILE:2}
		cp ./$LINKED_DIR/* $wd/$LINKED_DIR 2>/dev/null
		if [[ $FILE != "" ]]; then
			cp ./*.so $wd/$LINKED_DIR/lib$FILE 2>/dev/null
		fi
		cd $wd
	done

	#Do the make if we haven't run into any issues (and the .so isn't already there)
	if [ ! -f *.so ]; then
		printf "Build string (in $wd): \n$BUILD_STR\n\n"
		`$BUILD_STR`
	fi

}

wrapso "$@"

if [[ $SAVE_CHILDREN == 0 ]]; then
	for rmfile in ${DELETE_LIST[@]}; do
		rm -r "$rmfile"
	done
fi

if [ ! -f *.so ] && [ -f *.so.bup ]; then
	BUP_FILE=$(ls *.so.bup)
	BUP_FILE_LEN=${#BUP_FILE}
	mv $BUP_FILE "${BUP_FILE:0:BUP_FILE_LEN-4}"
elif [ -f *.so.bup ]; then
	rm *.so.bup
fi

printf "\nHave a great day!\n~Cardinal\n"
